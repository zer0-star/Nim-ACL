---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  _extendedRequiredBy:
  - icon: ':x:'
    path: atcoder/extra/math/coef_of_generating_function.nim
    title: atcoder/extra/math/coef_of_generating_function.nim
  - icon: ':x:'
    path: atcoder/extra/math/coef_of_generating_function.nim
    title: atcoder/extra/math/coef_of_generating_function.nim
  - icon: ':x:'
    path: atcoder/extra/math/coef_of_generating_function.nim
    title: atcoder/extra/math/coef_of_generating_function.nim
  - icon: ':x:'
    path: atcoder/extra/math/coef_of_generating_function.nim
    title: atcoder/extra/math/coef_of_generating_function.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':x:'
    path: atcoder/extra/math/factorial.nim
    title: atcoder/extra/math/factorial.nim
  - icon: ':x:'
    path: atcoder/extra/math/factorial.nim
    title: atcoder/extra/math/factorial.nim
  - icon: ':x:'
    path: atcoder/extra/math/factorial.nim
    title: atcoder/extra/math/factorial.nim
  - icon: ':x:'
    path: atcoder/extra/math/factorial.nim
    title: atcoder/extra/math/factorial.nim
  - icon: ':x:'
    path: atcoder/extra/math/formal_power_series_differential_equation.nim
    title: atcoder/extra/math/formal_power_series_differential_equation.nim
  - icon: ':x:'
    path: atcoder/extra/math/formal_power_series_differential_equation.nim
    title: atcoder/extra/math/formal_power_series_differential_equation.nim
  - icon: ':x:'
    path: atcoder/extra/math/formal_power_series_differential_equation.nim
    title: atcoder/extra/math/formal_power_series_differential_equation.nim
  - icon: ':x:'
    path: atcoder/extra/math/formal_power_series_differential_equation.nim
    title: atcoder/extra/math/formal_power_series_differential_equation.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/formal_power_series_sqrt.nim
    title: atcoder/extra/math/formal_power_series_sqrt.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/formal_power_series_sqrt.nim
    title: atcoder/extra/math/formal_power_series_sqrt.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/formal_power_series_sqrt.nim
    title: atcoder/extra/math/formal_power_series_sqrt.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/formal_power_series_sqrt.nim
    title: atcoder/extra/math/formal_power_series_sqrt.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_convolution_test.nim
    title: verify/extra/math/arbitrary_mod_convolution_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_convolution_test.nim
    title: verify/extra/math/arbitrary_mod_convolution_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
    title: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
    title: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/division_of_polynomials_test.nim
    title: verify/extra/math/division_of_polynomials_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/division_of_polynomials_test.nim
    title: verify/extra/math/division_of_polynomials_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/exp_of_formal_power_series_test.nim
    title: verify/extra/math/exp_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/exp_of_formal_power_series_test.nim
    title: verify/extra/math/exp_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/inv_of_formal_power_series_test.nim
    title: verify/extra/math/inv_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/inv_of_formal_power_series_test.nim
    title: verify/extra/math/inv_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/log_of_formal_power_series_test.nim
    title: verify/extra/math/log_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/log_of_formal_power_series_test.nim
    title: verify/extra/math/log_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/polynomial_taylor_shift_test.nim
    title: verify/extra/math/polynomial_taylor_shift_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/polynomial_taylor_shift_test.nim
    title: verify/extra/math/polynomial_taylor_shift_test.nim
  - icon: ':x:'
    path: verify/extra/math/pow_of_formal_power_series_test.nim
    title: verify/extra/math/pow_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/pow_of_formal_power_series_test.nim
    title: verify/extra/math/pow_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/sqrt_of_formal_power_series_test.nim
    title: verify/extra/math/sqrt_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/sqrt_of_formal_power_series_test.nim
    title: verify/extra/math/sqrt_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
    title: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
    title: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
    title: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
    title: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
    title: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
    title: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_0963_differential_equation_test.nim
    title: verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_0963_differential_equation_test.nim
    title: verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_factorial_test.nim
    title: verify/extra/math/yukicoder_factorial_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_factorial_test.nim
    title: verify/extra/math/yukicoder_factorial_test.nim
  _isVerificationFailed: true
  _pathExtension: nim
  _verificationStatusIcon: ':question:'
  attributes:
    links: []
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.10.6/x64/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/opt/hostedtoolcache/Python/3.10.6/x64/lib/python3.10/site-packages/onlinejudge_verify/languages/nim.py\"\
    , line 86, in bundle\n    raise NotImplementedError\nNotImplementedError\n"
  code: "when not declared ATCODER_FORMAL_POWER_SERIES:\n  const ATCODER_FORMAL_POWER_SERIES*\
    \ = 1\n  \n  import std/sequtils, std/strformat, std/options, std/macros, std/tables,\
    \ std/algorithm\n  import atcoder/element_concepts\n\n  type FormalPowerSeries*[T:FieldElem]\
    \ = seq[T]\n  type Poly*[T:FieldElem] = FormalPowerSeries[T]\n\n  template initFormalPowerSeries*[T:FieldElem](n:int):FormalPowerSeries[T]\
    \ =\n    block:\n      FormalPowerSeries[T](newSeq[T](n))\n  template initFormalPowerSeries*[T:FieldElem;U:\
    \ not T](data:openArray[U]):FormalPowerSeries[T] =\n    block:\n      var result\
    \ = newSeq[T](data.len)\n      for i, it in data:\n        result[i] = T(it)\n\
    \      FormalPowerSeries[T](result)\n  template initFormalPowerSeries*[T:FieldElem](data:openArray[T]):FormalPowerSeries[T]\
    \ =\n    block:\n      data\n\n  template init*[T:FieldElem](self:typedesc[FormalPowerSeries[T]],\
    \ data:typed):auto =\n    initFormalPowerSeries[T](data)\n\n  # {{{ sparseFormalPowerSeries\n\
    \n  type SparseFormalPowerSeries*[T:FieldElem] = seq[tuple[d:int, c:T]] # sorted\
    \ ascending order\n\n#  converter toSparseFormalPowerSeries*[XI, T](a:array[XI,\
    \ (int, T)]):SparseFormalPowerSeries[T] = a.toSeq()\n\n  # SparseMonomial {{{\n\
    \  type Monomial*[T] = object\n    c:T\n    d:int\n  \n  proc initVar*[T](c =\
    \ 1, d = 1):SparseFormalPowerSeries[T] = @[(d:d, c:T(c))]\n  \n  proc `^`*[T](f:SparseFormalPowerSeries[T],\
    \ n:int):SparseFormalPowerSeries[T] =\n    assert f.len == 1\n    result.add(f[0])\n\
    \    result[0].d *= n\n    if f[0].c != T.init(1): result[0].c = result[0].c ^\
    \ n\n  \n#  converter toSFPS*[T](f:Monomial[T]):SparseFormalPowerSeries[T] = @[(f.d,f.c)]\n\
    \n#  proc `+`*[T](f, g: Monomial[T]):SparseFormalPowerSeries[T] =\n#    return\
    \ toSFPS(f) + toSFPS(g)\n\n  # }}}\n\n  converter toSFPS*[T](f:Table[int, T]):SparseFormalPowerSeries[T]\
    \ =\n    for d, c in f:\n      result.add((d, c))\n    result.sort do (x, y:(int,\
    \ T)) -> int:\n      cmp(x[0], y[0])\n\n#  converter toSFPS*[T](a:T):SparseFormalPowerSeries[T]\
    \ = @[(0, a)]\n  proc deg*[T](a:SparseFormalPowerSeries[T]):int = a[^1].d\n  proc\
    \ `+=`*[T](a:var SparseFormalPowerSeries[T], b:SparseFormalPowerSeries[T]) =\n\
    \    var r:SparseFormalPowerSeries[T]\n    var i, j = 0\n    while i < a.len or\
    \ j < b.len:\n      if i < a.len and j < b.len and a[i].d == b[j].d:\n       \
    \ r.add((a[i].d, a[i].c + b[j].c))\n        i.inc;j.inc\n      else:\n       \
    \ if j == b.len or (i < a.len and a[i].d < b[j].d):\n          r.add(a[i]);i.inc\n\
    \        else:\n          r.add(b[j]);j.inc\n    swap(r, a)\n  proc `+=`*[T](a:var\
    \ SparseFormalPowerSeries[T], b:T) = a += @[(0, b)]\n  proc `+=`*[T](a:var FormalPowerSeries[T],\
    \ b:SparseFormalPowerSeries[T]) =\n    for p in b:\n      while a.len <= p.d:\
    \ a.add(T.init(0))\n      a[p.d] += p.c\n  proc `-=`*[T](a:var SparseFormalPowerSeries[T],\
    \ b:SparseFormalPowerSeries[T]) =\n    var r:SparseFormalPowerSeries[T]\n    var\
    \ i, j = 0\n    while i < a.len or j < b.len:\n      if i < a.len and j < b.len\
    \ and a[i].d == b[j].d:\n        r.add((a[i].d, a[i].c - b[j].c))\n        i.inc;j.inc\n\
    \      else:\n        if j == b.len or (i < a.len and a[i].d < b[j].d):\n    \
    \      r.add(a[i]);i.inc\n        else:\n          r.add((b[j].d, -b[j].c));j.inc\n\
    \    swap(r, a)\n  proc `-=`*[T](a:var SparseFormalPowerSeries[T], b:T) = a -=\
    \ @[(0, b)]\n  proc `-=`*[T](a:var FormalPowerSeries[T], b:SparseFormalPowerSeries[T])\
    \ =\n    for p in b:\n      while a.len <= p.d: a.add(T.init(0))\n      a[p.d]\
    \ -= p.c\n\n  proc `*`*[T](a:FormalPowerSeries[T], b:SparseFormalPowerSeries[T],\
    \ deg = -1):FormalPowerSeries[T] =\n    var deg = deg\n    if deg == -1:\n   \
    \   let bdeg = b[^1][0]\n      deg = a.len + bdeg\n    result = initFormalPowerSeries[T](deg)\n\
    \    for i in 0..<a.len:\n      for (j, c) in b:\n        let k = i + j\n    \
    \    if k < deg: result[k] += a[i] * c\n  proc `*=`*[T](a:var SparseFormalPowerSeries[T],\
    \ b:SparseFormalPowerSeries[T], deg = -1) =\n    var r = initTable[int,T]()\n\
    \    for (i, c0) in a:\n      for (j, c1) in b:\n        let k = i + j\n     \
    \   if deg != -1 and k >= deg: continue\n        if k notin r: r[k] = T.init(0)\n\
    \        r[k] += c0 * c1\n    var rs = SparseFormalPowerSeries[T](r)\n    swap(rs,\
    \ a)\n  proc `*=`*[T](a:var SparseFormalPowerSeries[T], b:T) =\n    for (i, c)\
    \ in a.mitems:\n      c = c * b\n  proc `*`*[T](a:SparseFormalPowerSeries[T],\
    \ b:T):SparseFormalPowerSeries[T] =\n    result = a\n    result *= b\n  proc `*`*[T](b:T,\
    \ a:var SparseFormalPowerSeries[T]):SparseFormalPowerSeries[T] =\n    result =\
    \ a\n    for (i, c) in result.mitems:\n      c = b * c\n\n  macro declareSparseFormalPowerSeriesOperators(op)\
    \ =\n    fmt\"\"\"proc `{op}`*[T](self:SparseFormalPowerSeries[T];r:SparseFormalPowerSeries[T]\
    \ or T):SparseFormalPowerSeries[T] = result = self;result {op}= r\nproc `{op}`*[T](self:\
    \ not SparseFormalPowerSeries and not Monomial, r:SparseFormalPowerSeries[T]):SparseFormalPowerSeries[T]\
    \ = result = @[(0, T(self))];result {op}= r\"\"\".parsestmt\n\n  declareSparseFormalPowerSeriesOperators(`+`)\n\
    \  declareSparseFormalPowerSeriesOperators(`-`)\n  declareSparseFormalPowerSeriesOperators(`*`)\n\
    \n  proc divMod*[T](a: FormalPowerSeries[T], b:SparseFormalPowerSeries[T]):(FormalPowerSeries[T],\
    \ FormalPowerSeries[T]) =\n    mixin inv\n    var a = a\n    let\n      max_deg\
    \ = b[^1][0]\n      inv_max_coef = b[^1][1].inv\n    var q = initFormalPowerSeries[T](a.len\
    \ - max_deg)\n    for i in countdown(q.len - 1, 0):\n      q[i] = a[i + max_deg]\
    \ * inv_max_coef\n      for (d, v) in b:\n        a[i + d] -= q[i] * v\n    return\
    \ (q, a[0..<max_deg])\n  proc `div`*[T:FieldElem](a: FormalPowerSeries[T], b:SparseFormalPowerSeries[T]):auto\
    \ = a.divMod(b)[0]\n  proc `mod`*[T:FieldElem](a: FormalPowerSeries[T], b:SparseFormalPowerSeries[T]):auto\
    \ = a.divMod(b)[1]\n  # }}}\n\n  macro revise*(a, b) =\n    parseStmt(fmt\"\"\"\
    let {a.repr} = if {a.repr} == -1: {b.repr} else: {a.repr}\"\"\")\n  proc shrink*[T](self:\
    \ var FormalPowerSeries[T]) =\n    while self.len > 0 and self[^1] == 0: discard\
    \ self.pop()\n  proc resize*[T](self: var FormalPowerSeries[T], n:int) =\n   \
    \ mixin setLen\n    let l = self.len\n    self.setLen(n)\n    if l < n:\n    \
    \  for i in l ..< n:\n        self[i] = T(0)\n\n  converter toFPS*[T](f:Monomial[T]):FormalPowerSeries[T]\
    \ = \n    result = newSeq[T](f.d + 1)\n    result[f.d] = f.c\n  converter toFPS*[T](f:SparseFormalPowerSeries[T]):FormalPowerSeries[T]\
    \ = \n    let d = f.deg\n    result = initFormalPowerSeries[T](newSeqWith(d +\
    \ 1, T.init(0)))\n    for p in f: result[p.d] += p.c\n\n#  proc `+`*[T](f, g:\
    \ Monomial[T]):FormalPowerSeries[T] =\n#    return toFPS(f) + toFPS(g)\n  \n \
    \ proc `*`*[T](f, g:Monomial[T]):Monomial[T] =\n    result.c = f.c * g.c\n   \
    \ result.d = f.d + g.d\n  proc `*`*[T](a:T, f:Monomial[T]):Monomial[T] =\n   \
    \ result = f\n    result.c *= a\n  proc `*`*[T](a:SomeInteger, f:Monomial[T]):Monomial[T]\
    \ =\n    result = f\n    result.c *= T.init(a)\n  # }}}\n\n  # operators +=, -=,\
    \ *=, mod=, -, /= {{{\n  proc `+=`*[T](self: var FormalPowerSeries[T], r:FormalPowerSeries[T])\
    \ =\n    if r.len > self.len: self.setlen(r.len)\n    for i in 0..<r.len: self[i]\
    \ += r[i]\n  proc `+=`*[T](self: var FormalPowerSeries[T], r:T) =\n    if self.len\
    \ == 0: self.setlen(1)\n    self[0] += r\n  \n  proc `-=`*[T](self: var FormalPowerSeries[T],\
    \ r:FormalPowerSeries[T]) =\n    if r.len > self.len: self.setlen(r.len)\n   \
    \ for i in 0..<r.len: self[i] -= r[i]\n#    self.shrink()\n  proc `-=`*[T](self:\
    \ var FormalPowerSeries[T], r:T) =\n    if self.len == 0: self.setlen(1)\n   \
    \ self[0] -= r\n#    self.shrink()\n\n  proc `*=`*[T](self: var FormalPowerSeries[T],\
    \ v:T) = self.applyIt(it * v)\n\n  proc multRaw*[T](a, b:FormalPowerSeries[T]):FormalPowerSeries[T]\
    \ =\n    result = initFormalPowerSeries[T](a.len + b.len - 1)\n    for i in 0..<a.len:\n\
    \      for j in 0..<b.len:\n        result[i + j] += a[i] * b[j]\n\n  proc `*=`*[T](self:\
    \ var FormalPowerSeries[T],  r: FormalPowerSeries[T]) =\n    if self.len == 0\
    \ or r.len == 0:\n      self.setlen(0)\n    else:\n      mixin multiply\n    \
    \  self = multiply(self, r)\n\n  proc `mod=`*[T](self: var FormalPowerSeries[T],\
    \ r:FormalPowerSeries[T]) =\n    self -= (self div r) * r\n    self.resize(r.len\
    \ - 1)\n\n  proc `-`*[T](self: FormalPowerSeries[T]):FormalPowerSeries[T] =\n\
    \    var ret = self\n    ret.applyIt(-it)\n    return ret\n  proc `/=`*[T](self:\
    \ var FormalPowerSeries[T], v:T) = self.applyIt(it / v)\n  #}}}\n\n  proc rev*[T](self:\
    \ FormalPowerSeries[T], deg = -1):auto =\n    result = self\n    if deg != -1:\
    \ result.setlen(deg)\n    result.reverse\n  \n  proc pre*[T](self: FormalPowerSeries[T],\
    \ sz:int):auto =\n    result = self\n    result.setlen(min(self.len, sz))\n  \n\
    \  proc `shr`*[T](self: FormalPowerSeries[T], sz:int):auto =\n    if self.len\
    \ <= sz: return initFormalPowerSeries[T](0)\n    result = self\n    if sz >= 1:\
    \ result.delete(0, sz - 1)\n  proc `shl`*[T](self: FormalPowerSeries[T], sz:int):auto\
    \ =\n    result = initFormalPowerSeries[T](sz)\n    result = result & self\n \
    \ \n  proc diff*[T](self: FormalPowerSeries[T]):auto =\n    let n = self.len\n\
    \    result = initFormalPowerSeries[T](max(0, n - 1))\n    for i in 1..<n:\n \
    \     result[i - 1] = self[i] * T(i)\n  \n  proc integral*[T](self: FormalPowerSeries[T]):auto\
    \ =\n    let n = self.len\n    result = initFormalPowerSeries[T](n + 1)\n    result[0]\
    \ = T(0)\n    for i in 0..<n: result[i + 1] = self[i] / T(i + 1)\n  proc EQUAL*[T](a,\
    \ b:T):bool =\n    when T is hasInf:\n      return (abs(a - b) < T(0.0000001))\n\
    \    else:\n      return a == b\n\n  # F(0) must not be 0\n  proc inv*[T](self:\
    \ FormalPowerSeries[T], deg = -1):auto =\n    assert(not EQUAL(self[0], T(0)))\n\
    \    deg.revise(self.len)\n#    type F = T.get_fft_type()\n#    when T is ModInt:\n\
    \    when true:\n      proc invFast[T](self: FormalPowerSeries[T]):auto =\n# \
    \       assert(self[0] != T(0))\n        let n = self.len\n        var res = initFormalPowerSeries[T](1)\n\
    \        res[0] = T(1) / self[0]\n        var d = 1\n        while d < n:\n  \
    \        var f, g = initFormalPowerSeries[T](2 * d)\n          for j in 0..<min(n,\
    \ 2 * d): f[j] = self[j]\n          for j in 0..<d: g[j] = res[j]\n          let\
    \ g1 = fft(g)\n          f = ifft(dot(fft(f), g1, T), T)\n          for j in 0..<d:\n\
    \            f[j] = T(0)\n            f[j + d] = -f[j + d]\n          f = ifft(dot(fft(f),\
    \ g1, T), T)\n          f[0..<d] = res[0..<d]\n          res = f\n          d\
    \ = d shl 1\n        return res.pre(n)\n      var ret = self\n      ret.setlen(deg)\n\
    \      return ret.invFast()\n    else:\n      var ret = initFormalPowerSeries[T](1)\n\
    \      ret[0] = T(1) / self[0]\n      var i = 1\n      while i < deg:\n      \
    \  ret = (ret + ret - ret * ret * self.pre(i shl 1)).pre(i shl 1)\n        i =\
    \ i shl 1\n      return ret.pre(deg)\n  proc `/=`*[T](self: var FormalPowerSeries[T],\
    \ r: FormalPowerSeries[T]) =\n    self *= r.inv()\n\n  proc `div=`*[T](self: var\
    \ FormalPowerSeries[T], r: FormalPowerSeries[T]) =\n    if self.len < r.len:\n\
    \      self.resize(0)\n    else:\n      let n = self.len - r.len + 1\n      self\
    \ = (self.rev().pre(n) * r.rev().inv(n)).pre(n).rev(n)\n\n# operators +, -, *,\
    \ div, mod {{{\n  macro declareFormalPowerSeriesOperators(op) =\n    fmt\"\"\"\
    proc `{op}`*[T](self:FormalPowerSeries[T];r:FormalPowerSeries[T] or T):FormalPowerSeries[T]\
    \ = result = self;result {op}= r\nproc `{op}`*[T](self: not FormalPowerSeries\
    \ and not Monomial, r:FormalPowerSeries[T]):FormalPowerSeries[T] = result = initFormalPowerSeries[T](@[T(self)]);result\
    \ {op}= r\"\"\".parseStmt\n  \n  declareFormalPowerSeriesOperators(`+`)\n  declareFormalPowerSeriesOperators(`-`)\n\
    \  declareFormalPowerSeriesOperators(`*`)\n  declareFormalPowerSeriesOperators(`/`)\n\
    \  \n  proc `div`*[T](self, r:FormalPowerSeries[T]):FormalPowerSeries[T] = result\
    \ = self;result.`div=` (r)\n  proc `mod`*[T](self, r:FormalPowerSeries[T]):FormalPowerSeries[T]\
    \ = result = self;result.`mod=` (r)\n  # }}}\n  \n  # F(0) must be 1\n  proc log*[T](self:FormalPowerSeries[T],\
    \ deg = -1):auto =\n    assert EQUAL(self[0], T(1))\n    deg.revise(self.len)\n\
    \    return (self.diff() * self.inv(deg)).pre(deg - 1).integral()\n\n  proc expFast[T:FieldElem](self:\
    \ FormalPowerSeries[T], deg:int):auto =\n    deg.revise(self.len)\n    assert\
    \ EQUAL(self[0], T(0))\n\n    var inv = newSeqOfCap[T](deg + 1)\n    inv.add(T(0))\n\
    \    inv.add(T(1))\n\n    proc inplace_integral(F:var FormalPowerSeries[T]) =\n\
    \      let\n        n = F.len\n      when T is FiniteFieldElem:\n        let\n\
    \          M = T.mod\n      while inv.len <= n:\n        let i = inv.len\n   \
    \     when T is FiniteFieldElem:\n          inv.add((-inv[M mod i]) * (M div i))\n\
    \        else:\n          inv.add(T(1)/T(i))\n      F = @[T(0)] & F\n      for\
    \ i in 1..n: F[i] *= inv[i]\n\n    proc inplace_diff(F:var FormalPowerSeries[T]):auto\
    \ =\n      if F.len == 0: return\n      F = F[1..<F.len]\n      var coeff = T(1)\n\
    \      let one = T(1)\n      for i in 0..<F.len:\n        F[i] *= coeff\n    \
    \    coeff += one\n    mixin fft, ifft, dot\n    type FFTType = fft(initFormalPowerSeries[T](0)).type\n\
    \    mixin inplace_partial_dot\n    var\n      b = @[T(1), if 1 < self.len: self[1]\
    \ else: T(0)]\n      c = @[T(1)]\n      z1f:FFTType\n      z2 = @[T(1), T(0)]\n\
    \      z2f = z2.fft\n    var m = 2\n    while m < deg:\n      var y = b\n    \
    \  y.resize(2 * m)\n      var yf = y.fft\n      z1f = z2f\n      var zf = yf\n\
    \      zf.setLen(m)\n      inplace_partial_dot(zf, z1f, 0..<m, T)\n      var z\
    \ = zf.ifft(T)\n      for i in 0..<m div 2: z[i] = T(0)\n      zf = z.fft\n  \
    \    z = ifft(dot(zf, z1f, T), T)\n      for i in 0..<m:z[i] *= -1\n      c =\
    \ c & z[m div 2..^1]\n      z2 = c\n      z2.resize(2 * m)\n      z2f = z2.fft\n\
    \      var x = self[0..<min(self.len, m)]\n      inplace_diff(x)\n      x.add(T(0))\n\
    \      var xf = x.fft\n      inplace_partial_dot(xf, yf, 0..<m, T)\n      x =\
    \ xf.ifft(T)\n      x -= b.diff()\n      x.resize(2 * m)\n      for i in 0..<m\
    \ - 1: x[m + i] = x[i]; x[i] = T(0)\n      xf = x.fft\n      inplace_partial_dot(xf,\
    \ z2f, 0..<2*m, T)\n      x = xf.ifft(T)\n      discard x.pop()\n      inplace_integral(x)\n\
    \      for i in m..<min(self.len, 2 * m): x[i] += self[i]\n      for i in 0..<m:\
    \ x[i] = T(0)\n      xf = x.fft\n      inplace_partial_dot(xf, yf, 0..<2*m, T)\n\
    \      x = xf.ifft(T)\n      b = b & x[m..^1]\n      m *= 2\n    return b[0..<deg]\n\
    \n#   F(0) must be 0\n  proc exp*[T](self: FormalPowerSeries[T], deg = -1):auto\
    \ =\n    assert EQUAL(self[0], T(0))\n    deg.revise(self.len)\n\n    when T is\
    \ FiniteFieldElem:\n      var self = self\n      self.resize(deg)\n      return\
    \ self.expFast(deg)\n    else:\n      var\n        ret = initFormalPowerSeries[T](@[T(1)])\n\
    \        i = 1\n      while i < deg:\n        ret = (ret * (self.pre(i shl 1)\
    \ + T(1) - ret.log(i shl 1))).pre(i shl 1)\n        i = i shl 1\n      return\
    \ ret.pre(deg)\n\n  proc pow*[T:FieldElem](self: FormalPowerSeries[T], k:int,\
    \ deg = -1):FormalPowerSeries[T] =\n    mixin pow, init\n    var self = self\n\
    \    deg.revise(self.len)\n    self.resize(deg)\n    for i in 0..<deg:\n     \
    \ if not EQUAL(self[i], T(0)):\n        let rev = T(1) / self[i]\n        result\
    \ = (((self * rev) shr i).log(deg) * T.init(k)).exp() * (self[i].pow(k))\n   \
    \     if i * k > deg: return initFormalPowerSeries[T](deg)\n        result = (result\
    \ shl (i * k)).pre(deg)\n        if result.len < deg: result.setlen(deg)\n   \
    \     return\n    return self\n\n  proc eval*[T](self: FormalPowerSeries[T], x:T):T\
    \ =\n    var\n      (r, w) = (T(0), T(1))\n    for v in self:\n      r += w *\
    \ v\n      w *= x\n    return r\n#  {.experimental: \"callOperator\".}\n#  template\
    \ `()`*[T](self: FormalPowerSeries[T], x:T):T = self.eval(x)\n#  proc `()`*[T](self:\
    \ FormalPowerSeries[T], x:T):T = self.eval(x)\n\n  proc powMod*[T](self: FormalPowerSeries[T],\
    \ n:int, M:FormalPowerSeries[T]):auto =\n    assert not EQUAL(M[^1], T(0))\n \
    \   let modinv = M.rev().inv()\n    proc getDiv(base:FormalPowerSeries[T]):FormalPowerSeries[T]\
    \ =\n      var base = base\n      if base.len < M.len:\n        base.setlen(0)\n\
    \        return base\n      let n = base.len - M.len + 1\n      return (base.rev().pre(n)\
    \ * modinv.pre(n)).pre(n).rev(n)\n    var\n      n = n\n      x = self\n    result\
    \ = initFormalPowerSeries[T](M.len - 1)\n    result[0] = T(1)\n    while n > 0:\n\
    \      if (n and 1) > 0:\n        result *= x\n        result -= getDiv(result)\
    \ * M\n        result = result.pre(M.len - 1)\n      x *= x\n      x -= getDiv(x)\
    \ * M\n      x = x.pre(M.len - 1)\n      n = n shr 1\n\n"
  dependsOn:
  - atcoder/element_concepts.nim
  - atcoder/element_concepts.nim
  - atcoder/element_concepts.nim
  - atcoder/element_concepts.nim
  isVerificationFile: false
  path: atcoder/extra/math/formal_power_series.nim
  requiredBy:
  - atcoder/extra/math/formal_power_series_differential_equation.nim
  - atcoder/extra/math/formal_power_series_differential_equation.nim
  - atcoder/extra/math/coef_of_generating_function.nim
  - atcoder/extra/math/coef_of_generating_function.nim
  - atcoder/extra/math/formal_power_series_sqrt.nim
  - atcoder/extra/math/formal_power_series_sqrt.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/factorial.nim
  - atcoder/extra/math/factorial.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/formal_power_series_differential_equation.nim
  - atcoder/extra/math/formal_power_series_differential_equation.nim
  - atcoder/extra/math/coef_of_generating_function.nim
  - atcoder/extra/math/coef_of_generating_function.nim
  - atcoder/extra/math/formal_power_series_sqrt.nim
  - atcoder/extra/math/formal_power_series_sqrt.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/factorial.nim
  - atcoder/extra/math/factorial.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  timestamp: '2022-08-08 21:23:55+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - verify/extra/math/arbitrary_mod_convolution_test.nim
  - verify/extra/math/arbitrary_mod_convolution_test.nim
  - verify/extra/math/exp_of_formal_power_series_test.nim
  - verify/extra/math/exp_of_formal_power_series_test.nim
  - verify/extra/math/polynomial_taylor_shift_test.nim
  - verify/extra/math/polynomial_taylor_shift_test.nim
  - verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - verify/extra/math/inv_of_formal_power_series_test.nim
  - verify/extra/math/inv_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - verify/extra/math/yukicoder_factorial_test.nim
  - verify/extra/math/yukicoder_factorial_test.nim
  - verify/extra/math/division_of_polynomials_test.nim
  - verify/extra/math/division_of_polynomials_test.nim
  - verify/extra/math/sqrt_of_formal_power_series_test.nim
  - verify/extra/math/sqrt_of_formal_power_series_test.nim
  - verify/extra/math/pow_of_formal_power_series_test.nim
  - verify/extra/math/pow_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - verify/extra/math/log_of_formal_power_series_test.nim
  - verify/extra/math/log_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
documentation_of: atcoder/extra/math/formal_power_series.nim
layout: document
redirect_from:
- /library/atcoder/extra/math/formal_power_series.nim
- /library/atcoder/extra/math/formal_power_series.nim.html
title: atcoder/extra/math/formal_power_series.nim
---
