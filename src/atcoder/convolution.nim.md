---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  - icon: ':question:'
    path: atcoder/element_concepts.nim
    title: atcoder/element_concepts.nim
  - icon: ':question:'
    path: atcoder/generate_definitions.nim
    title: atcoder/generate_definitions.nim
  - icon: ':question:'
    path: atcoder/generate_definitions.nim
    title: atcoder/generate_definitions.nim
  - icon: ':question:'
    path: atcoder/internal_bit.nim
    title: atcoder/internal_bit.nim
  - icon: ':question:'
    path: atcoder/internal_bit.nim
    title: atcoder/internal_bit.nim
  - icon: ':question:'
    path: atcoder/internal_math.nim
    title: atcoder/internal_math.nim
  - icon: ':question:'
    path: atcoder/internal_math.nim
    title: atcoder/internal_math.nim
  - icon: ':question:'
    path: atcoder/modint.nim
    title: atcoder/modint.nim
  - icon: ':question:'
    path: atcoder/modint.nim
    title: atcoder/modint.nim
  _extendedRequiredBy:
  - icon: ':question:'
    path: atcoder/extra/math/arbitrary_mod_convolution.nim
    title: atcoder/extra/math/arbitrary_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/arbitrary_mod_convolution.nim
    title: atcoder/extra/math/arbitrary_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/arbitrary_mod_convolution.nim
    title: atcoder/extra/math/arbitrary_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/arbitrary_mod_convolution.nim
    title: atcoder/extra/math/arbitrary_mod_convolution.nim
  - icon: ':x:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':x:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':x:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':x:'
    path: atcoder/extra/math/composition.nim
    title: atcoder/extra/math/composition.nim
  - icon: ':question:'
    path: atcoder/extra/math/ntt.nim
    title: atcoder/extra/math/ntt.nim
  - icon: ':question:'
    path: atcoder/extra/math/ntt.nim
    title: atcoder/extra/math/ntt.nim
  - icon: ':question:'
    path: atcoder/extra/math/ntt.nim
    title: atcoder/extra/math/ntt.nim
  - icon: ':question:'
    path: atcoder/extra/math/ntt.nim
    title: atcoder/extra/math/ntt.nim
  - icon: ':question:'
    path: atcoder/extra/math/particular_mod_convolution.nim
    title: atcoder/extra/math/particular_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/particular_mod_convolution.nim
    title: atcoder/extra/math/particular_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/particular_mod_convolution.nim
    title: atcoder/extra/math/particular_mod_convolution.nim
  - icon: ':question:'
    path: atcoder/extra/math/particular_mod_convolution.nim
    title: atcoder/extra/math/particular_mod_convolution.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  - icon: ':heavy_check_mark:'
    path: atcoder/extra/math/polynomial_taylor_shift.nim
    title: atcoder/extra/math/polynomial_taylor_shift.nim
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: verify/convolution_test.nim
    title: verify/convolution_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/convolution_test.nim
    title: verify/convolution_test.nim
  - icon: ':x:'
    path: verify/extra/graph/centroid_decomposition_test.nim
    title: verify/extra/graph/centroid_decomposition_test.nim
  - icon: ':x:'
    path: verify/extra/graph/centroid_decomposition_test.nim
    title: verify/extra/graph/centroid_decomposition_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_convolution_test.nim
    title: verify/extra/math/arbitrary_mod_convolution_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_convolution_test.nim
    title: verify/extra/math/arbitrary_mod_convolution_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
    title: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
    title: verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/convolution_montgomery_test.nim
    title: verify/extra/math/convolution_montgomery_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/convolution_montgomery_test.nim
    title: verify/extra/math/convolution_montgomery_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/division_of_polynomials_test.nim
    title: verify/extra/math/division_of_polynomials_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/division_of_polynomials_test.nim
    title: verify/extra/math/division_of_polynomials_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/exp_of_formal_power_series_test.nim
    title: verify/extra/math/exp_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/exp_of_formal_power_series_test.nim
    title: verify/extra/math/exp_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/inv_of_formal_power_series_test.nim
    title: verify/extra/math/inv_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/inv_of_formal_power_series_test.nim
    title: verify/extra/math/inv_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/log_of_formal_power_series_test.nim
    title: verify/extra/math/log_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/log_of_formal_power_series_test.nim
    title: verify/extra/math/log_of_formal_power_series_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/polynomial_taylor_shift_test.nim
    title: verify/extra/math/polynomial_taylor_shift_test.nim
  - icon: ':heavy_check_mark:'
    path: verify/extra/math/polynomial_taylor_shift_test.nim
    title: verify/extra/math/polynomial_taylor_shift_test.nim
  - icon: ':x:'
    path: verify/extra/math/pow_of_formal_power_series_test.nim
    title: verify/extra/math/pow_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/pow_of_formal_power_series_test.nim
    title: verify/extra/math/pow_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/sqrt_of_formal_power_series_test.nim
    title: verify/extra/math/sqrt_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/sqrt_of_formal_power_series_test.nim
    title: verify/extra/math/sqrt_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
    title: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
    title: verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
    title: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
    title: verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
    title: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - icon: ':x:'
    path: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
    title: verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_0963_differential_equation_test.nim
    title: verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_0963_differential_equation_test.nim
    title: verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_factorial_test.nim
    title: verify/extra/math/yukicoder_factorial_test.nim
  - icon: ':x:'
    path: verify/extra/math/yukicoder_factorial_test.nim
    title: verify/extra/math/yukicoder_factorial_test.nim
  _isVerificationFailed: true
  _pathExtension: nim
  _verificationStatusIcon: ':question:'
  attributes:
    links: []
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.10.7/x64/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/opt/hostedtoolcache/Python/3.10.7/x64/lib/python3.10/site-packages/onlinejudge_verify/languages/nim.py\"\
    , line 86, in bundle\n    raise NotImplementedError\nNotImplementedError\n"
  code: "when not declared ATCODER_CONVOLUTION_HPP:\n  const ATCODER_CONVOLUTION_HPP*\
    \ = 1\n\n  import std/math, std/sequtils, std/sugar\n  import atcoder/internal_math,\
    \ atcoder/internal_bit\n  import atcoder/element_concepts\n\n  type fft_info*[mint:FiniteFieldElem;\
    \ g, rank2:static[int]] = object\n    root, iroot: array[rank2 + 1, mint]\n  \
    \  rate2, irate2: array[max(0, rank2 - 2 + 1), mint]\n    rate3, irate3: array[max(0,\
    \ rank2 - 3 + 1), mint]\n\n  proc initFFTInfo*[mint:FiniteFieldElem]():auto =\n\
    \    const g = primitive_root[mint.mod]()\n    const rank2 = bsf(mint.mod - 1)\n\
    \    var root, iroot:array[rank2 + 1, mint]\n    var rate2, irate2: array[max(0,\
    \ rank2 - 2 + 1), mint]\n    var rate3, irate3: array[max(0, rank2 - 3 + 1), mint]\n\
    \    mixin init, inv\n\n    root[rank2] = mint.init(g).pow((mint.mod - 1) shr\
    \ rank2)\n    iroot[rank2] = root[rank2].inv()\n    for i in countdown(rank2 -\
    \ 1, 0):\n      root[i] = root[i + 1] * root[i + 1];\n      iroot[i] = iroot[i\
    \ + 1] * iroot[i + 1];\n  \n    block:\n      var\n        prod = mint.init(1)\n\
    \        iprod = mint.init(1)\n      for i in 0..rank2 - 2:\n        rate2[i]\
    \ = root[i + 2] * prod\n        irate2[i] = iroot[i + 2] * iprod\n        prod\
    \ *= iroot[i + 2]\n        iprod *= root[i + 2]\n    block:\n      var\n     \
    \   prod = mint.init(1)\n        iprod = mint.init(1)\n      for i in 0..rank2\
    \ - 3:\n        rate3[i] = root[i + 3] * prod;\n        irate3[i] = iroot[i +\
    \ 3] * iprod;\n        prod *= iroot[i + 3];\n        iprod *= root[i + 3];\n\
    \    return fft_info[mint, g, rank2](root:root, iroot:iroot, rate2:rate2, irate2:irate2,\
    \ rate3: rate3, irate3:irate3)\n  \n  proc butterfly*[mint:FiniteFieldElem](a:var\
    \ seq[mint]) =\n    mixin init\n    let n = a.len\n    let h = ceil_pow2(n)\n\n\
    \    const info = initFFTInfo[mint]()\n\n    var len = 0  # a[i, i+(n>>len), i+2*(n>>len),\
    \ ..] is transformed\n    while len < h:\n      if h - len == 1:\n        let\
    \ p = 1 shl (h - len - 1)\n        var rot = mint.init(1)\n        for s in 0..<(1\
    \ shl len):\n          var offset = s shl (h - len)\n          for i in 0..<p:\n\
    \            let l = a[i + offset]\n            let r = a[i + offset + p] * rot\n\
    \            a[i + offset] = l + r\n            a[i + offset + p] = l - r\n  \
    \        if s + 1 != (1 shl len):\n            rot *= info.rate2[bsf(not s.uint)]\n\
    \        len.inc\n      else:\n        # 4-base\n        let p = 1 shl (h - len\
    \ - 2)\n        var\n          rot = mint.init(1)\n          imag = info.root[2]\n\
    \        for s in 0..<(1 shl len):\n          let\n            rot2 = rot * rot\n\
    \            rot3 = rot2 * rot\n            offset = s shl (h - len)\n       \
    \   for i in 0..<p:\n            let\n              mod2 = (mint.mod() * mint.mod()).uint\n\
    \              a0 = (a[i + offset].val()).uint\n              a1 = (a[i + offset\
    \ + p].val() * rot.val()).uint\n              a2 = (a[i + offset + 2 * p].val()\
    \ * rot2.val()).uint\n              a3 = (a[i + offset + 3 * p].val() * rot3.val()).uint\n\
    \              a1na3imag = (mint.init(a1 + mod2 - a3).val() * imag.val()).uint\n\
    \              na2 = mod2 - a2\n            a[i + offset] = mint.init(a0 + a2\
    \ + a1 + a3)\n            a[i + offset + 1 * p] = mint.init(a0 + a2 + (2.uint\
    \ * mod2 - (a1 + a3)))\n            a[i + offset + 2 * p] = mint.init(a0 + na2\
    \ + a1na3imag)\n            a[i + offset + 3 * p] = mint.init(a0 + na2 + (mod2\
    \ - a1na3imag))\n          if s + 1 != (1 shl len):\n            rot *= info.rate3[bsf(not\
    \ s.uint)]\n        len += 2\n  \n  proc butterfly_inv*[mint:FiniteFieldElem](a:var\
    \ seq[mint]) =\n    let n = a.len\n    let h = ceilpow2(n)\n    mixin init\n\n\
    \    const info = initFFTInfo[mint]()\n  \n    var len = h;  # a[i, i+(n>>len),\
    \ i+2*(n>>len), ..] is transformed\n    while len > 0:\n      if len == 1:\n \
    \       let p = 1 shl (h - len)\n        var irot = mint.init(1)\n        for\
    \ s in 0..<(1 shl (len - 1)):\n          let offset = s shl (h - len + 1)\n  \
    \        for i in 0..<p:\n            let\n              l = a[i + offset]\n \
    \             r = a[i + offset + p]\n            a[i + offset] = l + r\n     \
    \       a[i + offset + p] = mint.init((mint.mod() + l.val() - r.val()) * irot.val())\n\
    \          if s + 1 != (1 shl (len - 1)):\n            irot *= info.irate2[bsf(not\
    \ s.uint)]\n        len.dec\n      else:\n        # 4-base\n        let p = 1\
    \ shl (h - len);\n        var irot = mint.init(1)\n        let iimag = info.iroot[2]\n\
    \        for s in 0..<(1 shl (len - 2)):\n          let\n            irot2 = irot\
    \ * irot\n            irot3 = irot2 * irot\n            offset = s shl (h - len\
    \ + 2)\n          for i in 0..<p:\n            let\n              a0 = a[i + offset\
    \ + 0 * p].val().uint\n              a1 = a[i + offset + 1 * p].val().uint\n \
    \             a2 = a[i + offset + 2 * p].val().uint\n              a3 = a[i +\
    \ offset + 3 * p].val().uint\n              a2na3iimag = mint.init((mint.mod.uint\
    \ + a2 - a3) * iimag.val().uint).val().uint\n  \n            a[i + offset] = mint.init(a0\
    \ + a1 + a2 + a3)\n            a[i + offset + 1 * p] = mint.init((a0 + (mint.mod().uint\
    \ - a1) + a2na3iimag) * irot.val().uint)\n            a[i + offset + 2 * p] =\
    \ mint.init((a0 + a1 + (mint.mod().uint - a2) + (mint.mod().uint - a3)) * irot2.val().uint)\n\
    \            a[i + offset + 3 * p] = mint.init((a0 + (mint.mod().uint - a1) +\
    \ (mint.mod().uint - a2na3iimag)) * irot3.val().uint)\n          if s + 1 != (1\
    \ shl (len - 2)):\n            irot *= info.irate3[bsf(not s.uint)]\n        len\
    \ -= 2\n\n  proc convolution_naive*[mint:FiniteFieldElem](a, b:seq[mint]):seq[mint]\
    \ =\n    mixin `+=`\n    let (n, m) = (a.len, b.len)\n    result = newSeq[mint](n\
    \ + m - 1)\n    if n < m:\n      for j in 0..<m:\n        for i in 0..<n:\n  \
    \        result[i + j] += a[i] * b[j]\n    else:\n      for i in 0..<n:\n    \
    \    for j in 0..<m:\n          result[i + j] += a[i] * b[j]\n\n  proc convolution_fft*[mint:FiniteFieldElem](a,\
    \ b:seq[mint]):seq[mint] =\n    mixin init, inv\n    let\n      (n, m) = (a.len,\
    \ b.len)\n      z = 1 shl ceil_pow2(n + m - 1)\n    var (a, b) = (a, b)\n    a.setLen(z)\n\
    \    butterfly(a)\n    b.setLen(z)\n    butterfly(b)\n    for i in 0..<z:\n  \
    \    a[i] *= b[i];\n    butterfly_inv(a)\n    a.setLen(n + m - 1)\n    let iz\
    \ = mint.init(z).inv()\n    for i in 0..<n + m - 1: a[i] *= iz\n    return a\n\
    \n  proc convolution*[mint:FiniteFieldElem](a, b:seq[mint]):seq[mint] =\n    let\
    \ (n, m) = (a.len, b.len)\n    if n == 0 or m == 0: return\n    if min(n, m) <=\
    \ 60: return convolution_naive(a, b)\n    return convolution_fft(a, b)\n\n  import\
    \ atcoder/modint\n  proc convolution*[T:SomeInteger](a, b:seq[T], M:static[uint]\
    \ = 998244353):seq[T] =\n    let (n, m) = (a.len, b.len)\n    if n == 0 or m ==\
    \ 0: return newSeq[T]()\n  \n    type mint = StaticModInt[M.int]\n    static:\n\
    \      assert mint is FiniteFieldElem\n    return convolution(\n      a.map((x:T)\
    \ => mint.init(x)), \n      b.map((x:T) => mint.init(x))\n    ).map((x:mint) =>\
    \ T(x.val()))\n\n  proc convolution_ll*(a, b:seq[int]):seq[int] =\n    let (n,\
    \ m) = (a.len, b.len)\n    if n == 0 or m == 0: return newSeq[int]()\n    const\n\
    \      MOD1:uint = 754974721  # 2^24\n      MOD2:uint = 167772161  # 2^25\n  \
    \    MOD3:uint = 469762049  # 2^26\n      M2M3 = MOD2 * MOD3\n      M1M3 = MOD1\
    \ * MOD3\n      M1M2 = MOD1 * MOD2\n      M1M2M3 = MOD1 * MOD2 * MOD3\n\n    \
    \  i1 = inv_gcd((MOD2 * MOD3).int, MOD1.int)[1].uint\n      i2 = inv_gcd((MOD1\
    \ * MOD3).int, MOD2.int)[1].uint\n      i3 = inv_gcd((MOD1 * MOD2).int, MOD3.int)[1].uint\n\
    \    \n    let\n      c1 = convolution(a, b, MOD1)\n      c2 = convolution(a,\
    \ b, MOD2)\n      c3 = convolution(a, b, MOD3)\n  \n    var c = newSeq[int](n\
    \ + m - 1)\n    for i in 0..<n + m - 1:\n      var x = 0.uint\n      x += (c1[i].uint\
    \ * i1) mod MOD1 * M2M3\n      x += (c2[i].uint * i2) mod MOD2 * M1M3\n      x\
    \ += (c3[i].uint * i3) mod MOD3 * M1M2\n      # B = 2^63, -B <= x, r(real value)\
    \ < B\n      # (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n      # r = c1[i] (mod\
    \ MOD1)\n      # focus on MOD1\n      # r = x, x - M', x - 2M', x - 3M' (M' =\
    \ M % 2^64) (mod 2B)\n      # r = x,\n      #   x - M' + (0 or 2B),\n      # \
    \  x - 2M' + (0, 2B or 4B),\n      #   x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n\
    \      # (r - x) = 0, (0)\n      #       - M' + (0 or 2B), (1)\n      #      \
    \ -2M' + (0 or 2B or 4B), (2)\n      #       -3M' + (0 or 2B or 4B or 6B) (3)\
    \ (mod MOD1)\n      # we checked that\n      #   ((1) mod MOD1) mod 5 = 2\n  \
    \    #   ((2) mod MOD1) mod 5 = 3\n      #   ((3) mod MOD1) mod 5 = 4\n#     \
    \ var diff = c1[i] - floorMod(x.int, MOD1.int)\n      var diff = c1[i] - floorMod(cast[int](x),\
    \ MOD1.int)\n      if diff < 0: diff += MOD1.int\n      const offset = [0'u, 0'u,\
    \ M1M2M3, 2'u * M1M2M3, 3'u * M1M2M3]\n      x -= offset[diff mod 5]\n      c[i]\
    \ = cast[int](x)\n    return c\n"
  dependsOn:
  - atcoder/modint.nim
  - atcoder/internal_bit.nim
  - atcoder/internal_bit.nim
  - atcoder/generate_definitions.nim
  - atcoder/element_concepts.nim
  - atcoder/generate_definitions.nim
  - atcoder/element_concepts.nim
  - atcoder/internal_math.nim
  - atcoder/modint.nim
  - atcoder/internal_math.nim
  isVerificationFile: false
  path: atcoder/convolution.nim
  requiredBy:
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/ntt.nim
  - atcoder/extra/math/ntt.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/arbitrary_mod_convolution.nim
  - atcoder/extra/math/arbitrary_mod_convolution.nim
  - atcoder/extra/math/particular_mod_convolution.nim
  - atcoder/extra/math/particular_mod_convolution.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/composition.nim
  - atcoder/extra/math/ntt.nim
  - atcoder/extra/math/ntt.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/polynomial_taylor_shift.nim
  - atcoder/extra/math/arbitrary_mod_convolution.nim
  - atcoder/extra/math/arbitrary_mod_convolution.nim
  - atcoder/extra/math/particular_mod_convolution.nim
  - atcoder/extra/math/particular_mod_convolution.nim
  timestamp: '2022-10-10 21:34:07+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - verify/convolution_test.nim
  - verify/convolution_test.nim
  - verify/extra/math/exp_of_formal_power_series_test.nim
  - verify/extra/math/exp_of_formal_power_series_test.nim
  - verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - verify/extra/math/yukicoder_0963_differential_equation_test.nim
  - verify/extra/math/inv_of_formal_power_series_test.nim
  - verify/extra/math/inv_of_formal_power_series_test.nim
  - verify/extra/math/convolution_montgomery_test.nim
  - verify/extra/math/convolution_montgomery_test.nim
  - verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - verify/extra/math/arbitrary_mod_exp_modsqrt_test.nim
  - verify/extra/math/polynomial_taylor_shift_test.nim
  - verify/extra/math/polynomial_taylor_shift_test.nim
  - verify/extra/math/sqrt_of_formal_power_series_test.nim
  - verify/extra/math/sqrt_of_formal_power_series_test.nim
  - verify/extra/math/division_of_polynomials_test.nim
  - verify/extra/math/division_of_polynomials_test.nim
  - verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_composition_of_formal_power_series_test.nim
  - verify/extra/math/arbitrary_mod_convolution_test.nim
  - verify/extra/math/arbitrary_mod_convolution_test.nim
  - verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - verify/extra/math/yosupo_kth_term_of_linearly_recurrent_sequence_test.nim
  - verify/extra/math/pow_of_formal_power_series_test.nim
  - verify/extra/math/pow_of_formal_power_series_test.nim
  - verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - verify/extra/math/yosupo_sharp_p_subset_sum_test.nim
  - verify/extra/math/yukicoder_factorial_test.nim
  - verify/extra/math/yukicoder_factorial_test.nim
  - verify/extra/math/log_of_formal_power_series_test.nim
  - verify/extra/math/log_of_formal_power_series_test.nim
  - verify/extra/graph/centroid_decomposition_test.nim
  - verify/extra/graph/centroid_decomposition_test.nim
documentation_of: atcoder/convolution.nim
layout: document
redirect_from:
- /library/atcoder/convolution.nim
- /library/atcoder/convolution.nim.html
title: atcoder/convolution.nim
---
